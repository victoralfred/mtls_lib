name: Comprehensive Tests

on:
  push:
    branches: [ main, develop, master ]
  pull_request:
    branches: [ main, develop, master ]
  workflow_dispatch:
    inputs:
      build_type:
        description: 'Build type'
        required: false
        default: 'Release'
        type: choice
        options:
          - Debug
          - Release
          - RelWithDebInfo
      enable_asan:
        description: 'Enable AddressSanitizer'
        required: false
        default: 'false'
        type: boolean
      enable_ubsan:
        description: 'Enable UndefinedBehaviorSanitizer'
        required: false
        default: 'false'
        type: boolean

env:
  BUILD_TYPE: ${{ github.event.inputs.build_type || 'Release' }}
  ENABLE_ASAN: ${{ github.event.inputs.enable_asan || 'false' }}
  ENABLE_UBSAN: ${{ github.event.inputs.enable_ubsan || 'false' }}

jobs:
  test-linux:
    name: Test on Linux
    runs-on: ubuntu-latest
    strategy:
      matrix:
        compiler: [gcc, clang]
        include:
          - compiler: gcc
            cc: gcc
            cxx: g++
          - compiler: clang
            cc: clang
            cxx: clang++
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          submodules: recursive

      - name: Install dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y \
            build-essential \
            cmake \
            libssl-dev \
            pkg-config \
            valgrind

      - name: Set up compiler
        run: |
          if [ "${{ matrix.compiler }}" = "clang" ]; then
            sudo apt-get install -y clang
          fi

      - name: Configure CMake
        run: |
          mkdir -p build
          cd build
          cmake .. \
            -DCMAKE_BUILD_TYPE=${{ env.BUILD_TYPE }} \
            -DCMAKE_C_COMPILER=${{ matrix.cc }} \
            -DCMAKE_CXX_COMPILER=${{ matrix.cxx }} \
            -DMTLS_BUILD_TESTS=ON \
            -DMTLS_BUILD_EXAMPLES=ON \
            -DMTLS_ENABLE_ASAN=${{ env.ENABLE_ASAN }} \
            -DMTLS_ENABLE_UBSAN=${{ env.ENABLE_UBSAN }}

      - name: Build
        run: |
          cd build
          cmake --build . --config ${{ env.BUILD_TYPE }} --parallel $(nproc)

      - name: Run tests
        run: |
          cd build
          ctest --output-on-failure --verbose

      - name: Run tests with Valgrind (Release builds only)
        if: env.BUILD_TYPE == 'Release' && matrix.compiler == 'gcc'
        run: |
          cd build
          valgrind --leak-check=full --show-leak-kinds=all --track-origins=yes \
            --error-exitcode=1 ctest --output-on-failure

      - name: Check test coverage
        if: matrix.compiler == 'gcc'
        run: |
          cd build
          # Generate coverage if gcov is available
          if command -v gcov &> /dev/null; then
            find . -name "*.gcda" -exec gcov {} \; || true
          fi

  test-linux-sanitizers:
    name: Test with Sanitizers (Linux)
    runs-on: ubuntu-latest
    strategy:
      matrix:
        sanitizer: [asan, ubsan, both]
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          submodules: recursive

      - name: Install dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y \
            build-essential \
            cmake \
            libssl-dev \
            pkg-config

      - name: Configure CMake with sanitizers
        run: |
          mkdir -p build
          cd build
          ASAN_FLAG="OFF"
          UBSAN_FLAG="OFF"
          if [ "${{ matrix.sanitizer }}" = "asan" ] || [ "${{ matrix.sanitizer }}" = "both" ]; then
            ASAN_FLAG="ON"
          fi
          if [ "${{ matrix.sanitizer }}" = "ubsan" ] || [ "${{ matrix.sanitizer }}" = "both" ]; then
            UBSAN_FLAG="ON"
          fi
          cmake .. \
            -DCMAKE_BUILD_TYPE=Debug \
            -DMTLS_BUILD_TESTS=ON \
            -DMTLS_ENABLE_ASAN=$ASAN_FLAG \
            -DMTLS_ENABLE_UBSAN=$UBSAN_FLAG

      - name: Build
        run: |
          cd build
          cmake --build . --config Debug --parallel $(nproc)

      - name: Run tests with sanitizers
        run: |
          cd build
          ctest --output-on-failure --verbose

  test-macos:
    name: Test on macOS
    runs-on: macos-latest
    strategy:
      matrix:
        compiler: [gcc, clang]
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          submodules: recursive

      - name: Install dependencies
        run: |
          brew install cmake openssl@3 pkg-config

      - name: Set up compiler
        if: matrix.compiler == 'gcc'
        run: |
          brew install gcc

      - name: Configure CMake
        run: |
          mkdir -p build
          cd build
          if [ "${{ matrix.compiler }}" = "gcc" ]; then
            CC=gcc-13 CXX=g++-13 cmake .. \
              -DCMAKE_BUILD_TYPE=${{ env.BUILD_TYPE }} \
              -DMTLS_BUILD_TESTS=ON \
              -DMTLS_BUILD_EXAMPLES=ON \
              -DMTLS_ENABLE_ASAN=${{ env.ENABLE_ASAN }} \
              -DMTLS_ENABLE_UBSAN=${{ env.ENABLE_UBSAN }}
          else
            cmake .. \
              -DCMAKE_BUILD_TYPE=${{ env.BUILD_TYPE }} \
              -DMTLS_BUILD_TESTS=ON \
              -DMTLS_BUILD_EXAMPLES=ON \
              -DMTLS_ENABLE_ASAN=${{ env.ENABLE_ASAN }} \
              -DMTLS_ENABLE_UBSAN=${{ env.ENABLE_UBSAN }}
          fi

      - name: Build
        run: |
          cd build
          cmake --build . --config ${{ env.BUILD_TYPE }} --parallel $(sysctl -n hw.ncpu)

      - name: Run tests
        run: |
          cd build
          ctest --output-on-failure --verbose

  test-windows:
    name: Test on Windows
    runs-on: windows-latest
    strategy:
      matrix:
        generator: ["Visual Studio 17 2022", "MinGW Makefiles"]
        build_type: [Release, Debug]
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          submodules: recursive

      - name: Install OpenSSL
        run: |
          choco install openssl -y
          # Wait for installation to complete
          Start-Sleep -Seconds 5

          # Find OpenSSL installation
          $possiblePaths = @(
            "C:\Program Files\OpenSSL-Win64",
            "C:\Program Files\OpenSSL",
            "C:\OpenSSL-Win64",
            "C:\OpenSSL"
          )

          $opensslRoot = $null
          foreach ($path in $possiblePaths) {
            if (Test-Path $path) {
              Write-Host "Found OpenSSL at: $path"
              $opensslRoot = $path
              break
            }
          }

          if (-not $opensslRoot) {
            Write-Error "OpenSSL not found in any expected location"
            exit 1
          }

          # List contents for debugging
          Write-Host "`nOpenSSL directory structure:"
          Get-ChildItem $opensslRoot | Format-Table Name

          if (Test-Path "$opensslRoot\lib") {
            Write-Host "`nLib directory contents:"
            Get-ChildItem "$opensslRoot\lib" -Include *.lib,*.a -Recurse | Select-Object FullName
          }

          # Find the actual library files
          Write-Host "`nSearching for library files..."

          # Prefer DLL import libraries over static libraries for MSVC
          # Look for libcrypto.lib (DLL import lib) first, then libcrypto_static.lib
          $cryptoLib = Get-ChildItem "$opensslRoot" -Recurse -Include "libcrypto.lib" -ErrorAction SilentlyContinue | Where-Object { $_.Name -eq "libcrypto.lib" } | Select-Object -First 1
          if (-not $cryptoLib) {
            # Fall back to static library
            $cryptoLib = Get-ChildItem "$opensslRoot" -Recurse -Include "libcrypto*.lib" -ErrorAction SilentlyContinue | Select-Object -First 1
          }

          $sslLib = Get-ChildItem "$opensslRoot" -Recurse -Include "libssl.lib" -ErrorAction SilentlyContinue | Where-Object { $_.Name -eq "libssl.lib" } | Select-Object -First 1
          if (-not $sslLib) {
            # Fall back to static library
            $sslLib = Get-ChildItem "$opensslRoot" -Recurse -Include "libssl*.lib" -ErrorAction SilentlyContinue | Select-Object -First 1
          }

          if ($cryptoLib) {
            Write-Host "`nFound crypto library: $($cryptoLib.FullName)"
            echo "OPENSSL_CRYPTO_LIBRARY=$($cryptoLib.FullName)" >> $env:GITHUB_ENV
          } else {
            Write-Error "CRITICAL: Could not find crypto library!"
          }

          if ($sslLib) {
            Write-Host "Found SSL library: $($sslLib.FullName)"
            echo "OPENSSL_SSL_LIBRARY=$($sslLib.FullName)" >> $env:GITHUB_ENV
          } else {
            Write-Error "CRITICAL: Could not find SSL library!"
          }

          # Set other OpenSSL paths
          echo "OPENSSL_ROOT_DIR=$opensslRoot" >> $env:GITHUB_ENV
          echo "OPENSSL_INCLUDE_DIR=$opensslRoot\include" >> $env:GITHUB_ENV

          # Verify what was set
          Write-Host "`nEnvironment variables that will be passed to CMake:"
          Write-Host "OPENSSL_ROOT_DIR=$opensslRoot"
          Write-Host "OPENSSL_INCLUDE_DIR=$opensslRoot\include"
          if ($cryptoLib) { Write-Host "OPENSSL_CRYPTO_LIBRARY=$($cryptoLib.FullName)" }
          if ($sslLib) { Write-Host "OPENSSL_SSL_LIBRARY=$($sslLib.FullName)" }
        shell: pwsh

      - name: Install dependencies (MSVC)
        if: matrix.generator == 'Visual Studio 17 2022'
        uses: microsoft/setup-msbuild@v2

      - name: Install dependencies (MinGW)
        if: matrix.generator == 'MinGW Makefiles'
        run: |
          choco install mingw -y
          choco install cmake -y
          # Install MSYS2 for MinGW-compatible OpenSSL
          choco install msys2 -y
          # Update MSYS2 and install OpenSSL
          C:\tools\msys64\usr\bin\bash.exe -lc "pacman -Syu --noconfirm"
          C:\tools\msys64\usr\bin\bash.exe -lc "pacman -S --noconfirm mingw-w64-x86_64-openssl"
          # Set OpenSSL paths for MinGW
          $mingwRoot = "C:\tools\msys64\mingw64"
          echo "MINGW_OPENSSL_ROOT=$mingwRoot" >> $env:GITHUB_ENV
          echo "MINGW_OPENSSL_INCLUDE=$mingwRoot\include" >> $env:GITHUB_ENV
          echo "MINGW_OPENSSL_CRYPTO=$mingwRoot\lib\libcrypto.dll.a" >> $env:GITHUB_ENV
          echo "MINGW_OPENSSL_SSL=$mingwRoot\lib\libssl.dll.a" >> $env:GITHUB_ENV
        shell: pwsh

      - name: Configure CMake (MSVC)
        if: matrix.generator == 'Visual Studio 17 2022'
        run: |
          # Debug: Verify environment variables are available
          Write-Host "Environment variables in Configure CMake step:"
          Write-Host "OPENSSL_ROOT_DIR=$env:OPENSSL_ROOT_DIR"
          Write-Host "OPENSSL_INCLUDE_DIR=$env:OPENSSL_INCLUDE_DIR"
          Write-Host "OPENSSL_CRYPTO_LIBRARY=$env:OPENSSL_CRYPTO_LIBRARY"
          Write-Host "OPENSSL_SSL_LIBRARY=$env:OPENSSL_SSL_LIBRARY"

          New-Item -ItemType Directory -Force -Path build | Out-Null
          Set-Location build
          cmake .. -G "${{ matrix.generator }}" -A x64 `
            -DMTLS_BUILD_TESTS=ON `
            -DMTLS_BUILD_EXAMPLES=ON `
            -DOPENSSL_ROOT_DIR="$env:OPENSSL_ROOT_DIR" `
            -DOPENSSL_INCLUDE_DIR="$env:OPENSSL_INCLUDE_DIR" `
            -DOPENSSL_CRYPTO_LIBRARY="$env:OPENSSL_CRYPTO_LIBRARY" `
            -DOPENSSL_SSL_LIBRARY="$env:OPENSSL_SSL_LIBRARY"
        shell: pwsh

      - name: Configure CMake (MinGW)
        if: matrix.generator == 'MinGW Makefiles'
        run: |
          # Debug: Verify environment variables are available
          Write-Host "Environment variables in Configure CMake step (MinGW):"
          Write-Host "MINGW_OPENSSL_ROOT=$env:MINGW_OPENSSL_ROOT"
          Write-Host "MINGW_OPENSSL_INCLUDE=$env:MINGW_OPENSSL_INCLUDE"
          Write-Host "MINGW_OPENSSL_CRYPTO=$env:MINGW_OPENSSL_CRYPTO"
          Write-Host "MINGW_OPENSSL_SSL=$env:MINGW_OPENSSL_SSL"

          New-Item -ItemType Directory -Force -Path build | Out-Null
          Set-Location build
          cmake .. -G "${{ matrix.generator }}" `
            -DCMAKE_BUILD_TYPE=${{ matrix.build_type }} `
            -DMTLS_BUILD_TESTS=ON `
            -DMTLS_BUILD_EXAMPLES=ON `
            -DOPENSSL_ROOT_DIR="$env:MINGW_OPENSSL_ROOT" `
            -DOPENSSL_INCLUDE_DIR="$env:MINGW_OPENSSL_INCLUDE" `
            -DOPENSSL_CRYPTO_LIBRARY="$env:MINGW_OPENSSL_CRYPTO" `
            -DOPENSSL_SSL_LIBRARY="$env:MINGW_OPENSSL_SSL"
        shell: pwsh

      - name: Build (MSVC)
        if: matrix.generator == 'Visual Studio 17 2022'
        run: |
          Set-Location build
          cmake --build . --config ${{ matrix.build_type }} --parallel
        shell: pwsh

      - name: Build (MinGW)
        if: matrix.generator == 'MinGW Makefiles'
        run: |
          Set-Location build
          cmake --build . --config ${{ matrix.build_type }} --parallel
        shell: pwsh

      - name: Run tests
        run: |
          Set-Location build
          ctest --output-on-failure --verbose -C ${{ matrix.build_type }}
        shell: pwsh

  test-static-analysis:
    name: Static Analysis
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          submodules: recursive

      - name: Install dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y \
            build-essential \
            cmake \
            libssl-dev \
            cppcheck \
            clang-tidy

      - name: Configure CMake
        run: |
          mkdir -p build
          cd build
          cmake .. \
            -DCMAKE_BUILD_TYPE=Debug \
            -DCMAKE_EXPORT_COMPILE_COMMANDS=ON \
            -DMTLS_BUILD_TESTS=ON

      - name: Build
        run: |
          cd build
          cmake --build . --parallel $(nproc)

      - name: Run cppcheck
        run: |
          cppcheck --enable=all --suppress=missingIncludeSystem \
            --suppress=unusedFunction --error-exitcode=1 \
            --project=build/compile_commands.json || true

      - name: Run clang-tidy
        run: |
          cd build
          # Skip non-native platform files (platform_win32.c and platform_darwin.c on Linux)
          find ../src ../include \( -name "*.c" -o -name "*.h" \) \
            ! -name "platform_win32.c" ! -name "platform_darwin.c" | \
            xargs clang-tidy -p . --warnings-as-errors=* || true

  test-integration:
    name: Integration Tests
    runs-on: ubuntu-latest
    needs: [test-linux]
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          submodules: recursive

      - name: Install dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y \
            build-essential \
            cmake \
            libssl-dev \
            pkg-config

      - name: Build library
        run: |
          mkdir -p build
          cd build
          cmake .. \
            -DCMAKE_BUILD_TYPE=Release \
            -DMTLS_BUILD_TESTS=ON \
            -DMTLS_BUILD_EXAMPLES=ON
          cmake --build . --parallel $(nproc)

      - name: Install library
        run: |
          cd build
          sudo cmake --install . --prefix /usr/local

      - name: Run integration tests
        run: |
          cd build
          ctest --output-on-failure --verbose -R integration || true
          # Run example programs as integration tests
          if [ -f examples/client ]; then
            ./examples/client --help || true
          fi
          if [ -f examples/server ]; then
            ./examples/server --help || true
          fi

  test-summary:
    name: Test Summary
    runs-on: ubuntu-latest
    needs: [test-linux, test-linux-sanitizers, test-macos, test-windows, test-static-analysis, test-integration]
    if: always()
    
    steps:
      - name: Check test results
        run: |
          echo "## Test Results Summary" >> $GITHUB_STEP_SUMMARY
          echo "| Job | Status |" >> $GITHUB_STEP_SUMMARY
          echo "|-----|--------|" >> $GITHUB_STEP_SUMMARY
          echo "| Linux (GCC) | ${{ needs.test-linux.result }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Linux (Clang) | ${{ needs.test-linux.result }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Linux Sanitizers | ${{ needs.test-linux-sanitizers.result }} |" >> $GITHUB_STEP_SUMMARY
          echo "| macOS | ${{ needs.test-macos.result }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Windows | ${{ needs.test-windows.result }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Static Analysis | ${{ needs.test-static-analysis.result }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Integration | ${{ needs.test-integration.result }} |" >> $GITHUB_STEP_SUMMARY


  notify-slack:
    name: Notify Slack
    runs-on: ubuntu-latest
    needs: [test-summary, test-linux, test-linux-sanitizers, test-macos, test-windows, test-static-analysis, test-integration]
    if: always()
    environment: production

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Determine build status
        id: build-status
        run: |
          # Check if all jobs succeeded
          if [ "${{ needs.test-linux.result }}" == "success" ] && \
             [ "${{ needs.test-linux-sanitizers.result }}" == "success" ] && \
             [ "${{ needs.test-macos.result }}" == "success" ] && \
             [ "${{ needs.test-windows.result }}" == "success" ] && \
             [ "${{ needs.test-static-analysis.result }}" == "success" ] && \
             [ "${{ needs.test-integration.result }}" == "success" ]; then
            echo "status=success" >> "$GITHUB_OUTPUT"
          else
            echo "status=failure" >> "$GITHUB_OUTPUT"
          fi

      - name: Build detailed test results
        id: test-details
        run: |
          # Get job status emojis
          get_status_emoji() {
            case "$1" in
              success) echo "✅" ;;
              failure) echo "❌" ;;
              cancelled) echo "⚠️" ;;
              *) echo "⏳" ;;
            esac
          }

          LINUX_EMOJI=$(get_status_emoji "${{ needs.test-linux.result }}")
          SANITIZERS_EMOJI=$(get_status_emoji "${{ needs.test-linux-sanitizers.result }}")
          MACOS_EMOJI=$(get_status_emoji "${{ needs.test-macos.result }}")
          WINDOWS_EMOJI=$(get_status_emoji "${{ needs.test-windows.result }}")
          STATIC_EMOJI=$(get_status_emoji "${{ needs.test-static-analysis.result }}")
          INTEGRATION_EMOJI=$(get_status_emoji "${{ needs.test-integration.result }}")

          # Build detailed status (properly escaped for JSON)
          cat > /tmp/details.txt <<EOF
          **Test Results:**
          ${LINUX_EMOJI} Linux Tests: \`${{ needs.test-linux.result }}\`
          ${SANITIZERS_EMOJI} Sanitizers: \`${{ needs.test-linux-sanitizers.result }}\`
          ${MACOS_EMOJI} macOS Tests: \`${{ needs.test-macos.result }}\`
          ${WINDOWS_EMOJI} Windows Tests: \`${{ needs.test-windows.result }}\`
          ${STATIC_EMOJI} Static Analysis: \`${{ needs.test-static-analysis.result }}\`
          ${INTEGRATION_EMOJI} Integration Tests: \`${{ needs.test-integration.result }}\`
          EOF

          echo "details<<EOF" >> "$GITHUB_OUTPUT"
          cat /tmp/details.txt >> "$GITHUB_OUTPUT"
          echo "EOF" >> "$GITHUB_OUTPUT"

      - name: Send Slack notification
        continue-on-error: true
        uses: ./.github/actions/slack-notify
        with:
          webhook-url: ${{ secrets.SLACK_WEBHOOK_URL }}
          workflow-name: "Test Suite"
          job-status: ${{ steps.build-status.outputs.status }}
          job-details: ${{ steps.test-details.outputs.details }}