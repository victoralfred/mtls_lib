#!/bin/bash
#
# Pre-commit hook for mTLS library
# Validates code against industrial standards before allowing commit
#
# To bypass this hook in emergencies: git commit --no-verify
#

set -e

# Color codes for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Configuration
PROJECT_ROOT=$(git rev-parse --show-toplevel)
CLANG_FORMAT_VERSION=14
MIN_COVERAGE=80

echo -e "${BLUE}========================================${NC}"
echo -e "${BLUE}  mTLS Pre-Commit Validation${NC}"
echo -e "${BLUE}========================================${NC}\n"

# Track overall status
VALIDATION_FAILED=0

#
# Step 1: Check for clang-format
#
step_clang_format() {
    echo -e "${YELLOW}[1/7] Checking code formatting...${NC}"

    if ! command -v clang-format &> /dev/null; then
        echo -e "${YELLOW}  ⚠ clang-format not found, skipping format check${NC}"
        echo -e "${YELLOW}  Install: sudo apt-get install clang-format${NC}\n"
        return 0
    fi

    # Get list of staged C/H files
    STAGED_FILES=$(git diff --cached --name-only --diff-filter=ACM | grep -E '\.(c|h)$' || true)

    if [ -z "$STAGED_FILES" ]; then
        echo -e "${GREEN}  ✓ No C/H files to check${NC}\n"
        return 0
    fi

    FORMATTING_ISSUES=0
    for file in $STAGED_FILES; do
        if [ -f "$file" ]; then
            # Check if file needs formatting
            clang-format --style=file --dry-run -Werror "$file" 2>/dev/null || {
                echo -e "${RED}  ✗ Formatting issues in: $file${NC}"
                echo -e "${YELLOW}    Fix with: clang-format -i $file${NC}"
                FORMATTING_ISSUES=1
            }
        fi
    done

    if [ $FORMATTING_ISSUES -eq 0 ]; then
        echo -e "${GREEN}  ✓ All files properly formatted${NC}\n"
        return 0
    else
        echo -e "${RED}  ✗ Formatting check failed${NC}"
        echo -e "${YELLOW}  Run: make format (or clang-format -i <files>)${NC}\n"
        return 1
    fi
}

#
# Step 2: Static analysis with clang-tidy
#
step_clang_tidy() {
    echo -e "${YELLOW}[2/7] Running static analysis (clang-tidy)...${NC}"

    if ! command -v clang-tidy &> /dev/null; then
        echo -e "${YELLOW}  ⚠ clang-tidy not found, skipping static analysis${NC}"
        echo -e "${YELLOW}  Install: sudo apt-get install clang-tidy${NC}\n"
        return 0
    fi

    # Check if build directory exists with compile_commands.json
    if [ ! -f "$PROJECT_ROOT/build/compile_commands.json" ]; then
        echo -e "${YELLOW}  ⚠ Build directory not configured, skipping clang-tidy${NC}"
        echo -e "${YELLOW}  Run: cmake -DCMAKE_EXPORT_COMPILE_COMMANDS=ON ..${NC}\n"
        return 0
    fi

    # Get staged C files
    STAGED_C_FILES=$(git diff --cached --name-only --diff-filter=ACM | grep '\.c$' || true)

    if [ -z "$STAGED_C_FILES" ]; then
        echo -e "${GREEN}  ✓ No C files to analyze${NC}\n"
        return 0
    fi

    # Detect platform for skipping non-native platform files
    CURRENT_OS=$(uname -s)

    TIDY_ISSUES=0

    for file in $STAGED_C_FILES; do
        if [ -f "$file" ]; then
            # Skip non-native platform files (they won't compile on this platform)
            case "$CURRENT_OS" in
                Linux)
                    if echo "$file" | grep -qE "platform_(darwin|win32)\.c$"; then
                        echo -e "${YELLOW}  Skipping: $file (non-native platform)${NC}"
                        continue
                    fi
                    ;;
                Darwin)
                    if echo "$file" | grep -qE "platform_(linux|win32)\.c$"; then
                        echo -e "${YELLOW}  Skipping: $file (non-native platform)${NC}"
                        continue
                    fi
                    ;;
                MINGW*|MSYS*|CYGWIN*)
                    if echo "$file" | grep -qE "platform_(linux|darwin)\.c$"; then
                        echo -e "${YELLOW}  Skipping: $file (non-native platform)${NC}"
                        continue
                    fi
                    ;;
            esac
            echo -e "${YELLOW}  Analyzing: $file${NC}"

            # Run clang-tidy and capture output
            TIDY_OUTPUT=$(clang-tidy -p build "$file" 2>&1 || true)

            # Check if there are any warnings or errors
            if echo "$TIDY_OUTPUT" | grep -E "warning:|error:" > /dev/null; then
                echo -e "${RED}  ✗ Issues found in: $file${NC}"
                echo "$TIDY_OUTPUT" | grep -E "(warning:|error:)" | head -20
                echo ""
                TIDY_ISSUES=1
            else
                echo -e "${GREEN}  ✓ No issues${NC}"
            fi
        fi
    done

    if [ $TIDY_ISSUES -eq 0 ]; then
        echo -e "${GREEN}  ✓ Static analysis passed${NC}\n"
        return 0
    else
        echo -e "${RED}  ✗ Static analysis found issues (see above for details)${NC}\n"
        return 1
    fi
}

#
# Step 3: Check with cppcheck
#
step_cppcheck() {
    echo -e "${YELLOW}[3/7] Running cppcheck...${NC}"

    if ! command -v cppcheck &> /dev/null; then
        echo -e "${YELLOW}  ⚠ cppcheck not found, skipping${NC}"
        echo -e "${YELLOW}  Install: sudo apt-get install cppcheck${NC}\n"
        return 0
    fi

    # Detect platform for excluding non-native platform files
    CURRENT_OS=$(uname -s)
    EXCLUDE_PLATFORMS=""

    case "$CURRENT_OS" in
        Linux)
            EXCLUDE_PLATFORMS="-i$PROJECT_ROOT/src/internal/platform_darwin.c -i$PROJECT_ROOT/src/internal/platform_win32.c"
            ;;
        Darwin)
            EXCLUDE_PLATFORMS="-i$PROJECT_ROOT/src/internal/platform_linux.c -i$PROJECT_ROOT/src/internal/platform_win32.c"
            ;;
        MINGW*|MSYS*|CYGWIN*)
            EXCLUDE_PLATFORMS="-i$PROJECT_ROOT/src/internal/platform_linux.c -i$PROJECT_ROOT/src/internal/platform_darwin.c"
            ;;
    esac

    # Run cppcheck on src and include directories
    CPPCHECK_OUTPUT=$(cppcheck --enable=warning,style,performance,portability \
                               --error-exitcode=1 \
                               --suppress=missingIncludeSystem \
                               --suppress=unusedFunction \
                               --inline-suppr \
                               $EXCLUDE_PLATFORMS \
                               -I"$PROJECT_ROOT/include" \
                               "$PROJECT_ROOT/src" 2>&1 || echo "CPPCHECK_FAILED")

    if echo "$CPPCHECK_OUTPUT" | grep "CPPCHECK_FAILED" > /dev/null; then
        echo -e "${RED}  ✗ cppcheck found issues:${NC}"
        echo "$CPPCHECK_OUTPUT" | grep -E "(error|warning|style|performance|portability):" | grep -v "Checking"
        echo ""
        return 1
    else
        echo -e "${GREEN}  ✓ cppcheck passed${NC}\n"
        return 0
    fi
}

#
# Step 4: Build the project
#
step_build() {
    echo -e "${YELLOW}[4/7] Building project...${NC}"

    if [ ! -d "$PROJECT_ROOT/build" ]; then
        echo -e "${YELLOW}  Creating build directory...${NC}"
        mkdir -p "$PROJECT_ROOT/build"
        cd "$PROJECT_ROOT/build"
        cmake .. > /dev/null 2>&1 || {
            echo -e "${RED}  ✗ CMake configuration failed${NC}\n"
            return 1
        }
    fi

    cd "$PROJECT_ROOT/build"

    # Clean build to ensure we catch all errors
    if make clean > /dev/null 2>&1 && make -j$(nproc) 2>&1 | tee /tmp/mtls_build.log | grep -E "error:|warning:"; then
        # Check if there were errors
        if grep -q "error:" /tmp/mtls_build.log; then
            echo -e "${RED}  ✗ Build failed with errors${NC}\n"
            return 1
        fi

        # Check for warnings
        WARNING_COUNT=$(grep -c "warning:" /tmp/mtls_build.log || echo "0")
        if [ "$WARNING_COUNT" -gt 0 ]; then
            echo -e "${YELLOW}  ⚠ Build succeeded with $WARNING_COUNT warnings${NC}"
        fi
    fi

    if [ -f "$PROJECT_ROOT/build/libmtls.a" ]; then
        echo -e "${GREEN}  ✓ Build successful${NC}\n"
        return 0
    else
        echo -e "${RED}  ✗ Build failed${NC}\n"
        return 1
    fi
}

#
# Step 5: Run tests
#
step_tests() {
    echo -e "${YELLOW}[5/7] Running tests...${NC}"

    cd "$PROJECT_ROOT/build"

    if ! ctest --output-on-failure 2>&1 | tee /tmp/mtls_tests.log; then
        echo -e "${RED}  ✗ Tests failed${NC}\n"
        return 1
    fi

    # Check test results
    if grep -q "100% tests passed" /tmp/mtls_tests.log; then
        echo -e "${GREEN}  ✓ All tests passed${NC}\n"
        return 0
    else
        echo -e "${RED}  ✗ Some tests failed${NC}\n"
        return 1
    fi
}

#
# Step 6: Security checks
#
step_security() {
    echo -e "${YELLOW}[6/7] Running security checks...${NC}"

    SECURITY_ISSUES=0

    # Check for common security issues in staged files
    STAGED_FILES=$(git diff --cached --name-only --diff-filter=ACM | grep -E '\.(c|h)$' || true)

    if [ -z "$STAGED_FILES" ]; then
        echo -e "${GREEN}  ✓ No files to check${NC}\n"
        return 0
    fi

    for file in $STAGED_FILES; do
        if [ -f "$file" ]; then
            # Check for dangerous functions
            if grep -nE '\b(strcpy|strcat|sprintf|gets)\(' "$file" > /dev/null; then
                echo -e "${RED}  ✗ Unsafe function usage in: $file${NC}"
                grep -nE '\b(strcpy|strcat|sprintf|gets)\(' "$file" | head -3
                SECURITY_ISSUES=1
            fi

            # Check for potential buffer overflows
            if grep -nE 'char\s+\w+\[' "$file" | grep -v 'const' > /dev/null; then
                # This is just a warning, not a failure
                echo -e "${YELLOW}  ⚠ Fixed-size buffers in: $file (review manually)${NC}"
            fi
        fi
    done

    if [ $SECURITY_ISSUES -eq 0 ]; then
        echo -e "${GREEN}  ✓ Security check passed${NC}\n"
        return 0
    else
        echo -e "${RED}  ✗ Security issues found${NC}"
        echo -e "${YELLOW}  Use safe alternatives: strncpy, strncat, snprintf${NC}\n"
        return 1
    fi
}

#
# Step 7: Check commit message
#
step_commit_message() {
    echo -e "${YELLOW}[7/7] Validating commit message format...${NC}"

    # Get the commit message from git
    COMMIT_MSG_FILE="$PROJECT_ROOT/.git/COMMIT_EDITMSG"

    if [ ! -f "$COMMIT_MSG_FILE" ]; then
        echo -e "${YELLOW}  ⚠ Cannot validate commit message yet${NC}\n"
        return 0
    fi

    COMMIT_MSG=$(cat "$COMMIT_MSG_FILE" 2>/dev/null || echo "")

    # Skip if empty (will be filled in editor)
    if [ -z "$COMMIT_MSG" ] || [ "$COMMIT_MSG" = "" ]; then
        return 0
    fi

    # Check for minimum message length
    if [ ${#COMMIT_MSG} -lt 10 ]; then
        echo -e "${RED}  ✗ Commit message too short (minimum 10 characters)${NC}\n"
        return 1
    fi

    echo -e "${GREEN}  ✓ Commit message format OK${NC}\n"
    return 0
}

#
# Main execution
#
main() {
    # Run all validation steps
    step_clang_format || VALIDATION_FAILED=1
    step_clang_tidy || VALIDATION_FAILED=1
    step_cppcheck || VALIDATION_FAILED=1
    step_build || VALIDATION_FAILED=1
    step_tests || VALIDATION_FAILED=1
    step_security || VALIDATION_FAILED=1
    step_commit_message || VALIDATION_FAILED=1

    echo -e "${BLUE}========================================${NC}"

    if [ $VALIDATION_FAILED -eq 0 ]; then
        echo -e "${GREEN}✓ All validation checks passed!${NC}"
        echo -e "${GREEN}  Commit allowed to proceed${NC}"
        echo -e "${BLUE}========================================${NC}\n"
        exit 0
    else
        echo -e "${RED}✗ Validation failed${NC}"
        echo -e "${YELLOW}  Fix the issues above or use:${NC}"
        echo -e "${YELLOW}  git commit --no-verify${NC}"
        echo -e "${YELLOW}  (only for emergencies)${NC}"
        echo -e "${BLUE}========================================${NC}\n"
        exit 1
    fi
}

# Run main function
main
