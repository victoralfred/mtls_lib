#!/bin/bash
#
# Pre-commit hook for mTLS library
# Validates code against industrial standards before allowing commit
#
# To bypass this hook in emergencies: git commit --no-verify
#

set -e

# Color codes for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Configuration
PROJECT_ROOT=$(git rev-parse --show-toplevel)
CLANG_FORMAT_VERSION=14
MIN_COVERAGE=80

echo -e "${BLUE}========================================${NC}"
echo -e "${BLUE}  mTLS Pre-Commit Validation${NC}"
echo -e "${BLUE}========================================${NC}\n"

# Track overall status
VALIDATION_FAILED=0

#
# Step 1: Check for clang-format
#
step_clang_format() {
    echo -e "${YELLOW}[1/7] Checking code formatting...${NC}"

    if ! command -v clang-format &> /dev/null; then
        echo -e "${YELLOW}  âš  clang-format not found, skipping format check${NC}"
        echo -e "${YELLOW}  Install: sudo apt-get install clang-format${NC}\n"
        return 0
    fi

    # Get list of staged C/H files
    STAGED_FILES=$(git diff --cached --name-only --diff-filter=ACM | grep -E '\.(c|h)$' || true)

    if [ -z "$STAGED_FILES" ]; then
        echo -e "${GREEN}  âœ“ No C/H files to check${NC}\n"
        return 0
    fi

    FORMATTING_ISSUES=0
    for file in $STAGED_FILES; do
        if [ -f "$file" ]; then
            # Check if file needs formatting
            clang-format --style=file --dry-run -Werror "$file" 2>/dev/null || {
                echo -e "${RED}  âœ— Formatting issues in: $file${NC}"
                echo -e "${YELLOW}    Fix with: clang-format -i $file${NC}"
                FORMATTING_ISSUES=1
            }
        fi
    done

    if [ $FORMATTING_ISSUES -eq 0 ]; then
        echo -e "${GREEN}  âœ“ All files properly formatted${NC}\n"
        return 0
    else
        echo -e "${RED}  âœ— Formatting check failed${NC}"
        echo -e "${YELLOW}  Run: make format (or clang-format -i <files>)${NC}\n"
        return 1
    fi
}

#
# Step 2: Static analysis with clang-tidy
#
step_clang_tidy() {
    echo -e "${YELLOW}[2/7] Running static analysis (clang-tidy)...${NC}"

    if ! command -v clang-tidy &> /dev/null; then
        echo -e "${YELLOW}  âš  clang-tidy not found, skipping static analysis${NC}"
        echo -e "${YELLOW}  Install: sudo apt-get install clang-tidy${NC}\n"
        return 0
    fi

    # Get staged C files
    STAGED_C_FILES=$(git diff --cached --name-only --diff-filter=ACM | grep '\.c$' || true)

    if [ -z "$STAGED_C_FILES" ]; then
        echo -e "${GREEN}  âœ“ No C files to analyze${NC}\n"
        return 0
    fi

    TIDY_ISSUES=0
    for file in $STAGED_C_FILES; do
        if [ -f "$file" ]; then
            # Run clang-tidy
            if ! clang-tidy "$file" -p build -- -I"$PROJECT_ROOT/include" -I"$PROJECT_ROOT/src" 2>&1 | \
                 grep -E "warning:|error:" > /dev/null; then
                echo -e "${GREEN}  âœ“ $file passed${NC}"
            else
                echo -e "${RED}  âœ— Issues found in: $file${NC}"
                TIDY_ISSUES=1
            fi
        fi
    done

    if [ $TIDY_ISSUES -eq 0 ]; then
        echo -e "${GREEN}  âœ“ Static analysis passed${NC}\n"
        return 0
    else
        echo -e "${RED}  âœ— Static analysis found issues${NC}\n"
        return 1
    fi
}

#
# Step 3: Check with cppcheck
#
step_cppcheck() {
    echo -e "${YELLOW}[3/7] Running cppcheck...${NC}"

    if ! command -v cppcheck &> /dev/null; then
        echo -e "${YELLOW}  âš  cppcheck not found, skipping${NC}"
        echo -e "${YELLOW}  Install: sudo apt-get install cppcheck${NC}\n"
        return 0
    fi

    # Run cppcheck on src and include directories
    if cppcheck --enable=warning,style,performance,portability \
                --error-exitcode=1 \
                --suppress=missingIncludeSystem \
                --quiet \
                -I"$PROJECT_ROOT/include" \
                "$PROJECT_ROOT/src" 2>&1 | grep -v "Checking"; then
        echo -e "${GREEN}  âœ“ cppcheck passed${NC}\n"
        return 0
    else
        echo -e "${RED}  âœ— cppcheck found issues${NC}\n"
        return 1
    fi
}

#
# Step 4: Build the project
#
step_build() {
    echo -e "${YELLOW}[4/7] Building project...${NC}"

    if [ ! -d "$PROJECT_ROOT/build" ]; then
        echo -e "${YELLOW}  Creating build directory...${NC}"
        mkdir -p "$PROJECT_ROOT/build"
        cd "$PROJECT_ROOT/build"
        cmake .. > /dev/null 2>&1 || {
            echo -e "${RED}  âœ— CMake configuration failed${NC}\n"
            return 1
        }
    fi

    cd "$PROJECT_ROOT/build"

    # Clean build to ensure we catch all errors
    if make clean > /dev/null 2>&1 && make -j$(nproc) 2>&1 | tee /tmp/mtls_build.log | grep -E "error:|warning:"; then
        # Check if there were errors
        if grep -q "error:" /tmp/mtls_build.log; then
            echo -e "${RED}  âœ— Build failed with errors${NC}\n"
            return 1
        fi

        # Check for warnings
        WARNING_COUNT=$(grep -c "warning:" /tmp/mtls_build.log || echo "0")
        if [ "$WARNING_COUNT" -gt 0 ]; then
            echo -e "${YELLOW}  âš  Build succeeded with $WARNING_COUNT warnings${NC}"
        fi
    fi

    if [ -f "$PROJECT_ROOT/build/libmtls.a" ]; then
        echo -e "${GREEN}  âœ“ Build successful${NC}\n"
        return 0
    else
        echo -e "${RED}  âœ— Build failed${NC}\n"
        return 1
    fi
}

#
# Step 5: Run tests
#
step_tests() {
    echo -e "${YELLOW}[5/7] Running tests...${NC}"

    cd "$PROJECT_ROOT/build"

    if ! ctest --output-on-failure 2>&1 | tee /tmp/mtls_tests.log; then
        echo -e "${RED}  âœ— Tests failed${NC}\n"
        return 1
    fi

    # Check test results
    if grep -q "100% tests passed" /tmp/mtls_tests.log; then
        echo -e "${GREEN}  âœ“ All tests passed${NC}\n"
        return 0
    else
        echo -e "${RED}  âœ— Some tests failed${NC}\n"
        return 1
    fi
}

#
# Step 6: Security checks
#
step_security() {
    echo -e "${YELLOW}[6/7] Running security checks...${NC}"

    SECURITY_ISSUES=0

    # Check for common security issues in staged files
    STAGED_FILES=$(git diff --cached --name-only --diff-filter=ACM | grep -E '\.(c|h)$' || true)

    if [ -z "$STAGED_FILES" ]; then
        echo -e "${GREEN}  âœ“ No files to check${NC}\n"
        return 0
    fi

    for file in $STAGED_FILES; do
        if [ -f "$file" ]; then
            # Check for dangerous functions
            if grep -nE '\b(strcpy|strcat|sprintf|gets)\(' "$file" > /dev/null; then
                echo -e "${RED}  âœ— Unsafe function usage in: $file${NC}"
                grep -nE '\b(strcpy|strcat|sprintf|gets)\(' "$file" | head -3
                SECURITY_ISSUES=1
            fi

            # Check for potential buffer overflows
            if grep -nE 'char\s+\w+\[' "$file" | grep -v 'const' > /dev/null; then
                # This is just a warning, not a failure
                echo -e "${YELLOW}  âš  Fixed-size buffers in: $file (review manually)${NC}"
            fi
        fi
    done

    if [ $SECURITY_ISSUES -eq 0 ]; then
        echo -e "${GREEN}  âœ“ Security check passed${NC}\n"
        return 0
    else
        echo -e "${RED}  âœ— Security issues found${NC}"
        echo -e "${YELLOW}  Use safe alternatives: strncpy, strncat, snprintf${NC}\n"
        return 1
    fi
}

#
# Step 7: Check commit message
#
step_commit_message() {
    echo -e "${YELLOW}[7/7] Validating commit message format...${NC}"

    # Get the commit message from git
    COMMIT_MSG_FILE="$PROJECT_ROOT/.git/COMMIT_EDITMSG"

    if [ ! -f "$COMMIT_MSG_FILE" ]; then
        echo -e "${YELLOW}  âš  Cannot validate commit message yet${NC}\n"
        return 0
    fi

    COMMIT_MSG=$(cat "$COMMIT_MSG_FILE" 2>/dev/null || echo "")

    # Skip if empty (will be filled in editor)
    if [ -z "$COMMIT_MSG" ] || [ "$COMMIT_MSG" = "" ]; then
        return 0
    fi

    # Check for minimum message length
    if [ ${#COMMIT_MSG} -lt 10 ]; then
        echo -e "${RED}  âœ— Commit message too short (minimum 10 characters)${NC}\n"
        return 1
    fi

    # Check for Claude attribution (as per user requirements)
    if echo "$COMMIT_MSG" | grep -iE "claude|ðŸ¤–|co-authored-by.*claude" > /dev/null; then
        echo -e "${RED}  âœ— Commit message contains Claude attribution${NC}"
        echo -e "${YELLOW}  Remove Claude attribution from commit message${NC}\n"
        return 1
    fi

    echo -e "${GREEN}  âœ“ Commit message format OK${NC}\n"
    return 0
}

#
# Main execution
#
main() {
    # Run all validation steps
    step_clang_format || VALIDATION_FAILED=1
    step_clang_tidy || VALIDATION_FAILED=1
    step_cppcheck || VALIDATION_FAILED=1
    step_build || VALIDATION_FAILED=1
    step_tests || VALIDATION_FAILED=1
    step_security || VALIDATION_FAILED=1
    step_commit_message || VALIDATION_FAILED=1

    echo -e "${BLUE}========================================${NC}"

    if [ $VALIDATION_FAILED -eq 0 ]; then
        echo -e "${GREEN}âœ“ All validation checks passed!${NC}"
        echo -e "${GREEN}  Commit allowed to proceed${NC}"
        echo -e "${BLUE}========================================${NC}\n"
        exit 0
    else
        echo -e "${RED}âœ— Validation failed${NC}"
        echo -e "${YELLOW}  Fix the issues above or use:${NC}"
        echo -e "${YELLOW}  git commit --no-verify${NC}"
        echo -e "${YELLOW}  (only for emergencies)${NC}"
        echo -e "${BLUE}========================================${NC}\n"
        exit 1
    fi
}

# Run main function
main
